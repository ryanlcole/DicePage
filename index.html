<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dice Moon – Hex Pixel Engine</title>
<style>
  html,body{
    margin:0;height:100%;
    background:#000;color:#0f0;overflow:hidden;
    font-family:consolas,monospace;
  }
  #hud{
    position:fixed;left:10px;top:10px;
    background:rgba(0,0,0,0.5);
    padding:6px 10px;border:1px solid #0f0;
    border-radius:6px;font-size:13px;
  }
  canvas{display:block;position:fixed;inset:0;}
</style>
</head>
<body>
<div id="hud">HEX PIXEL ENGINE – click to paint hexes</div>
<canvas id="screen"></canvas>

<script>
// === BASIC PIXEL ENGINE ===
const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');
let w,h,img,buf32;
function resize(){
  w=innerWidth;h=innerHeight;
  canvas.width=w;canvas.height=h;
  img=ctx.getImageData(0,0,w,h);
  buf32=new Uint32Array(img.data.buffer);
}
addEventListener('resize',resize);resize();

// === PIXEL DRAW ===
function pset(x,y,r,g,b){
  if(x<0||y<0||x>=w||y>=h)return;
  buf32[y*w+x]=(255<<24)|(b<<16)|(g<<8)|r;
}

// === HEX GRID ===
const hexSize=12;              // pixel radius of one hex cell
const hexW=Math.sqrt(3)*hexSize;
const hexH=2*hexSize*0.75;     // vertical spacing
const cols=Math.ceil(w/hexW)+2;
const rows=Math.ceil(h/hexH)+2;

let hexes=[];
function makeHexes(){
  hexes=[];
  const cx=w/2, cy=h/2;
  for(let r=-rows/2;r<rows/2;r++){
    for(let q=-cols/2;q<cols/2;q++){
      const x=cx+hexW*(q+ r/2);
      const y=cy+hexH*r;
      const color=Math.floor(Math.random()*360);
      hexes.push({q,r,x,y,hue:color,phase:Math.random()*Math.PI*2});
    }
  }
}
makeHexes();

// === HEX MATH HELPERS ===
function hexAt(x,y){
  // convert pixel->axial
  const q=(x-w/2)/hexW - (y-h/2)/(2*hexH);
  const r=(y-h/2)/hexH;
  return {q:Math.round(q),r:Math.round(r)};
}

// === EVENT: PAINT ===
canvas.addEventListener('click',e=>{
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left, my=e.clientY-rect.top;
  const hxy=hexAt(mx,my);
  const h=hexes.find(hh=>hh.q===hxy.q&&hh.r===hxy.r);
  if(h){ h.hue=(h.hue+60)%360; } // cycle hue
});

// === FRAME ===
let t0=performance.now();
function frame(){
  const t=(performance.now()-t0)*0.001;
  const cx=w>>1, cy=h>>1;

  for(let i=0;i<w*h;i++) buf32[i]=0xFF000000; // clear

  // draw each hex
  for(const hcell of hexes){
    const {x,y,hue,phase}=hcell;
    const pulse=(Math.sin(t*2+phase)*0.3+0.7);
    const col=HSVtoRGB(hue/360,1.0,pulse);
    drawHex(x,y,hexSize,col.r,col.g,col.b);
  }

  ctx.putImageData(img,0,0);
  requestAnimationFrame(frame);
}
frame();

// === DRAW SINGLE HEX ===
function drawHex(cx,cy,r,R,G,B){
  const step=60*(Math.PI/180);
  for(let a=0;a<2*Math.PI;a+=0.5){
    const x=cx+r*Math.cos(a), y=cy+r*Math.sin(a);
    for(let dr=-r*0.7;dr<r*0.7;dr++){
      const xx=cx+(r+dr)*Math.cos(a);
      const yy=cy+(r+dr)*Math.sin(a);
      pset(xx|0,yy|0,R,G,B);
    }
  }
}

// === HSV→RGB (for pretty hues) ===
function HSVtoRGB(h,s,v){
  let r,g,b;
  const i=Math.floor(h*6);
  const f=h*6-i;
  const p=v*(1-s);
  const q=v*(1-f*s);
  const t=v*(1-(1-f)*s);
  switch(i%6){
    case 0:r=v;g=t;b=p;break;
    case 1:r=q;g=v;b=p;break;
    case 2:r=p;g=v;b=t;break;
    case 3:r=p;g=q;b=v;break;
    case 4:r=t;g=p;b=v;break;
    case 5:r=v;g=p;b=q;break;
  }
  return {r:(r*255)|0,g:(g*255)|0,b:(b*255)|0};
}
</script>
</body>
</html>
<!-- Mirror Build Wed Oct  8 15:40:48 UTC 2025 -->
