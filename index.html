<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Shaelvien Dice Mall</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden;color:#f8e7c7;font-family:system-ui;}
  #banner{position:fixed;top:2rem;left:2rem;z-index:10;pointer-events:none;
    font-size:clamp(28px,4.5vw,54px);text-shadow:0 0 24px #7b6130;}
  #gl{position:fixed;inset:0;display:block;}
</style>
</head>
<body>
<div id="banner">Shaelvien<br>Dice Mall</div>
<canvas id="gl"></canvas>

<script>
(() => {
  const c = document.getElementById('gl');
  const gl = c.getContext('webgl2', {antialias:true,alpha:false});
  if(!gl){document.body.innerHTML="WebGL2 required";return;}

  const resize=()=>{const dpr=Math.min(2,devicePixelRatio||1);
    const w=innerWidth*dpr,h=innerHeight*dpr;
    if(c.width!==w||c.height!==h){c.width=w;c.height=h;gl.viewport(0,0,w,h);}
  };
  addEventListener('resize',resize);resize();

  const vs=`#version 300 es
  precision highp float;
  layout(location=0)in vec3 p;
  uniform mat4 uP,uV,uM;
  out vec3 vN; out vec3 vW;
  flat out int vFace;
  void main(){
    vec4 wp=uM*vec4(p,1.0);
    vW=wp.xyz;
    vN=mat3(uM)*normalize(p);
    vFace = gl_VertexID / 3;
    gl_Position=uP*uV*wp;
  }`;

  const fs=`#version 300 es
  precision highp float;
  in vec3 vN,vW; flat in int vFace; out vec4 o;
  uniform vec3 uC; uniform float uT;
  const vec3 L=normalize(vec3(0.8,1.0,0.6));

  vec3 diamondColor(int id, float t){
    // Cycle hues through pastel diamond shades
    float h = float(id)/20.0 + t*0.05;
    float r = 0.5 + 0.5*sin(6.283*h);
    float g = 0.5 + 0.5*sin(6.283*h + 2.094);
    float b = 0.5 + 0.5*sin(6.283*h + 4.188);
    return mix(vec3(r,g,b), vec3(1.0), 0.3);
  }

  void main(){
    vec3 n=normalize(vN);
    float diff=max(dot(n,L),0.0);
    float edge=pow(1.0-abs(dot(n,L)),3.0);
    float spec=pow(max(dot(reflect(-L,n),normalize(uC-vW)),0.0),48.0);
    float rim=pow(1.0-max(dot(n,normalize(uC-vW)),0.0),2.5);

    vec3 base=diamondColor(vFace,uT);
    vec3 col=base*(0.25+0.9*diff)+spec*0.5+edge*0.15+rim*0.2;
    o=vec4(col,1.0);
  }`;

  function sh(t,s){const o=gl.createShader(t);gl.shaderSource(o,s);
    gl.compileShader(o);if(!gl.getShaderParameter(o,gl.COMPILE_STATUS))
      throw gl.getShaderInfoLog(o);return o;}
  function prog(v,f){const p=gl.createProgram();
    gl.attachShader(p,sh(gl.VERTEX_SHADER,v));
    gl.attachShader(p,sh(gl.FRAGMENT_SHADER,f));
    gl.linkProgram(p);if(!gl.getProgramParameter(p,gl.LINK_STATUS))
      throw gl.getProgramInfoLog(p);return p;}
  const P=prog(vs,fs);

  const t=(1+Math.sqrt(5))/2;
  const v=[-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1];
  for(let i=0;i<v.length;i+=3){let x=v[i],y=v[i+1],z=v[i+2],l=Math.hypot(x,y,z);v[i]/=l;v[i+1]/=l;v[i+2]/=l;}
  const f=[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
            [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]];
  const pArr=[];f.forEach(a=>a.forEach(i=>pArr.push(v[i*3],v[i*3+1],v[i*3+2])));
  const buf=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(pArr),gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);

  const uP=gl.getUniformLocation(P,"uP"),uV=gl.getUniformLocation(P,"uV"),
        uM=gl.getUniformLocation(P,"uM"),uC=gl.getUniformLocation(P,"uC"),
        uT=gl.getUniformLocation(P,"uT");

  // --- Math helpers ---
  const mI=()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
  const mMul=(a,b)=>{let r=new Array(16);
    for(let i=0;i<4;i++)for(let j=0;j<4;j++)
      r[i*4+j]=a[i*4]*b[j]+a[i*4+1]*b[4+j]+a[i*4+2]*b[8+j]+a[i*4+3]*b[12+j];return r;};
  const mRX=(m,a)=>{let c=Math.cos(a),s=Math.sin(a),r=[1,0,0,0,0,c,s,0,0,-s,c,0,0,0,0,1];return mMul(m,r);}
  const mRY=(m,a)=>{let c=Math.cos(a),s=Math.sin(a),r=[c,0,-s,0,0,1,0,0,s,0,c,0,0,0,0,1];return mMul(m,r);}
  const mP=(fov,asp,n,f)=>{let t=Math.tan(fov/2),r=[
    1/(asp*t),0,0,0,0,1/t,0,0,0,0,(f+n)/(n-f),-1,0,0,(2*f*n)/(n-f),0];return r;}
  const mLook=(e,c,u)=>{let zx=e[0]-c[0],zy=e[1]-c[1],zz=e[2]-c[2];
    let zl=Math.hypot(zx,zy,zz);zx/=zl;zy/=zl;zz/=zl;
    let xx=u[1]*zz-u[2]*zy,xy=u[2]*zx-u[0]*zz,xz=u[0]*zy-u[1]*zx;
    let xl=Math.hypot(xx,xy,xz);xx/=xl;xy/=xl;xz/=xl;
    let yx=zy*xz-zz*xy,yy=zz*xx-zx*xz,yz=zx*xy-zy*xx;
    return[xx,yx,zx,0,xy,yy,zy,0,xz,yz,zz,0,
           -(xx*e[0]+xy*e[1]+xz*e[2]),
           -(yx*e[0]+yy*e[1]+yz*e[2]),
           -(zx*e[0]+zy*e[1]+zz*e[2]),1];};

  let rx=0.4,ry=0.6,vx=0,vy=0,last=performance.now(),drag=false,lx,ly;
  c.onpointerdown=e=>{drag=true;lx=e.clientX;ly=e.clientY;};
  c.onpointermove=e=>{if(!drag)return;let dx=(e.clientX-lx)/innerWidth,dy=(e.clientY-ly)/innerHeight;
    lx=e.clientX;ly=e.clientY;ry+=dx*3.5;rx+=dy*3.5;vx=dx*6;vy=dy*6;last=performance.now();};
  c.onpointerup=()=>drag=false;c.onpointerleave=()=>drag=false;

  gl.enable(gl.DEPTH_TEST);gl.clearColor(0,0,0,1);

  const draw=t=>{
    resize();let T=t*0.001;
    if(!drag&&performance.now()-last>2000){ry+=0.25*0.016;}
    else{ry+=vx*0.016;rx+=vy*0.016;vx*=0.94;vy*=0.94;}
    rx=Math.max(-1.5,Math.min(1.5,rx));

    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    gl.useProgram(P);

    // Dynamically adjust camera distance to fit screen
    const fov=45*Math.PI/180;
    const aspect=c.width/c.height;
    const radius=1.1; // D20 bounds
    const distance=(radius/Math.sin(fov/2))*1.1; // keep margin
    const eye=[0,0,distance];

    let proj=mP(fov,aspect,0.1,50);
    let view=mLook(eye,[0,0,0],[0,1,0]);
    let model=mI();model=mRX(model,rx);model=mRY(model,ry);

    gl.uniformMatrix4fv(uP,false,new Float32Array(proj));
    gl.uniformMatrix4fv(uV,false,new Float32Array(view));
    gl.uniformMatrix4fv(uM,false,new Float32Array(model));
    gl.uniform3f(uC,eye[0],eye[1],eye[2]);
    gl.uniform1f(uT,T);
    gl.drawArrays(gl.TRIANGLES,0,pArr.length/3);
    requestAnimationFrame(draw);
  };
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>



<!-- Mirror Build Wed Oct  8 02:07:26 UTC 2025 -->
