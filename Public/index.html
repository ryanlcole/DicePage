<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
  <title>Shaelvien Dice Mall</title>
  <style>
    html,body {height:100%;margin:0;background:#05050b;overflow:hidden;}
    canvas {display:block;}
  </style>
</head>
<body>
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* ----------------------- renderer / scene / camera ----------------------- */
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 0.9, 6);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.minDistance = 3;
controls.maxDistance = 12;

/* ----------------------- Naeja galaxy env + sky ------------------------- */
const pmrem = new THREE.PMREMGenerator(renderer);
const galaxyTex = makeGalaxyEquirect(2048, 1024);
const envRT = pmrem.fromEquirectangular(galaxyTex);
scene.environment = envRT.texture;
scene.background = galaxyTex; // so stars also visible in the distance

// very faint large star sphere for parallax sparkle (moves a bit with time)
const starSphereGeom = new THREE.SphereGeometry(100, 64, 32);
const starSphereMat  = new THREE.MeshBasicMaterial({
  map: galaxyTex, side: THREE.BackSide, depthWrite:false
});
const starSphere = new THREE.Mesh(starSphereGeom, starSphereMat);
scene.add(starSphere);

/* ----------------------- lighting (moving sun) --------------------------- */
const sun = new THREE.DirectionalLight(0xffffff, 2.2);
sun.position.set(3, 2, 2);
sun.castShadow = false;
scene.add(sun);
scene.add(new THREE.AmbientLight(0x404040, 0.25));

/* ----------------------- D20 diamond (icosahedron) ---------------------- */
const radius = 1.65;
const ico = new THREE.IcosahedronGeometry(radius, 0);
ico.computeVertexNormals();

// face palette (your diamond colors)
const palette = [
  "#79a2d9", // blue
  "#8bc6a9", // green
  "#a9b585", // olive
  "#ead560", // yellow
  "#8a5a39", // brown
  "#ef9a34", // orange
  "#a01d2f", // red
  "#e893ad", // pink
  "#a27bd8", // purple
  "#1a1a1a", // black
  "#a6a6a6", // grey
  "#e6e6e6", // white
  "#79a2d9", "#8bc6a9", "#a9b585", "#ead560",
  "#8a5a39", "#ef9a34", "#a01d2f", "#e893ad"
];

// physical diamond-ish material
function makeDiamondMaterial(tintHex){
  const c = new THREE.Color(tintHex);
  return new THREE.MeshPhysicalMaterial({
    color: c,                         // slight body tint per facet
    roughness: 0.02,
    metalness: 0.0,
    transmission: 1.0,                // fully transmissive
    thickness: 0.26,                  // slab thickness for refraction
    ior: 2.417,                       // diamond IOR
    clearcoat: 1.0,
    clearcoatRoughness: 0.03,
    envMapIntensity: 1.25,
    attenuationColor: c.clone().multiplyScalar(0.85),
    attenuationDistance: 1.6,
    side: THREE.DoubleSide
  });
}

// Split the icosahedron into 20 triangle meshes so each face can have its own tint + number plane
const d20 = new THREE.Group();
const positions = ico.attributes.position.array;
for(let f=0; f<ico.index.count; f+=3){
  const ia = ico.index.array[f], ib = ico.index.array[f+1], ic = ico.index.array[f+2];
  const g = new THREE.BufferGeometry();
  const facePos = new Float32Array(9);
  copyV3(positions, ia, facePos, 0);
  copyV3(positions, ib, facePos, 3);
  copyV3(positions, ic, facePos, 6);
  g.setAttribute("position", new THREE.BufferAttribute(facePos, 3));
  g.computeVertexNormals();

  const mat = makeDiamondMaterial(palette[(f/3) % palette.length]);
  const tri = new THREE.Mesh(g, mat);

  // orient helper for placing the engraved number plane
  const vA = new THREE.Vector3(facePos[0], facePos[1], facePos[2]);
  const vB = new THREE.Vector3(facePos[3], facePos[4], facePos[5]);
  const vC = new THREE.Vector3(facePos[6], facePos[7], facePos[8]);
  const center = new THREE.Vector3().add(vA).add(vB).add(vC).multiplyScalar(1/3);
  const normal = new THREE.Vector3().subVectors(vB, vA).cross(new THREE.Vector3().subVectors(vC, vA)).normalize();

  // number plane: very slightly inset along normal so it's *inside* the gem (engraved)
  const planeSize = 1.08; // scale controls how much of the triangle the engraving occupies
  const numPlane = makeNumberPlane(((f/3)|0) + 1, planeSize);
  const up = new THREE.Vector3(0,0,1);
  const q = new THREE.Quaternion().setFromUnitVectors(up, normal.clone().normalize());
  numPlane.quaternion.copy(q);
  // fit plane onto the triangle: place at face center, then push inward a hair to look carved
  numPlane.position.copy(center).addScaledVector(normal, -0.02);
  d20.add(tri);
  d20.add(numPlane);
}
scene.add(d20);

/* ----------------------- liquid-in-engraving material -------------------- */
// Generates a plane with an SDF number mask; fragment animates a subtle “liquid”
function makeNumberPlane(n, scale=1.0){
  // equilateral-ish triangle plane (fits icosahedron faces) — build as a small plane then clip in shader
  const geom = new THREE.PlaneGeometry(scale, scale, 1, 1);

  const uniforms = {
    uTime: { value: 0 },
    uNumber: { value: n },
    uTint: { value: new THREE.Color(0xffffff) },
    uOpacity: { value: 0.85 } // liquid opacity
  };

  const mat = new THREE.ShaderMaterial({
    uniforms,
    transparent: true,
    depthWrite: false,
    blending: THREE.NormalBlending,
    side: THREE.DoubleSide,
    vertexShader: /* glsl */`
      varying vec2 vUv;
      void main(){
        vUv = uv * 2.0 - 1.0; // center at (0,0)
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `,
    fragmentShader: /* glsl */`
      precision highp float;
      varying vec2 vUv;
      uniform float uTime;
      uniform float uOpacity;
      uniform vec3  uTint;
      uniform float uNumber;

      // Simple 7-seg-ish SDF numerals so we avoid textures (keeps edges clean in refraction)
      // We’ll use a tiny signed distance “font”: each digit composed of rounded boxes.
      float rbox(vec2 p, vec2 b, float r){
        vec2 q = abs(p) - b;
        return length(max(q,0.0)) + min(max(q.x,q.y), 0.0) - r;
      }
      // draws a single digit 0..9 at p with size s; returns SDF < 0 inside
      float digitSDF(vec2 p, int d){
        // scale and position into 0..1 box
        p *= 1.0;
        // a tiny set of shapes for each digit (hand-tuned)
        float k = 1e5;
        if(d==0){
          k = min(k, rbox(p, vec2(0.45,0.80), 0.10));       // capsule-ish
          k = max(k, -rbox(p, vec2(0.28,0.60), 0.10));      // hollow
        } else if(d==1){
          vec2 q = p + vec2(0.15,0.1);
          k = rbox(q, vec2(0.15,0.85), 0.10);
        } else if(d==2){
          k = min(k, rbox(p+vec2(0.0,0.50), vec2(0.45,0.35), 0.10));
          k = max(k,-rbox(p-vec2(0.0,0.15), vec2(0.45,0.35), 0.10));
          k = min(k, rbox(p-vec2(0.0,0.65), vec2(0.45,0.35), 0.10));
        } else if(d==3){
          k = rbox(p, vec2(0.45,0.80), 0.10);
          k = max(k,-rbox(p-vec2(0.10,0.0), vec2(0.35,0.65), 0.10));
        } else if(d==4){
          k = min(rbox(p+vec2(-0.15,0.0), vec2(0.20,0.80), 0.10),
                  rbox(p+vec2(0.15,0.15), vec2(0.20,0.65), 0.10));
          k = min(k, rbox(p+vec2(0.0,0.10), vec2(0.55,0.15), 0.10));
        } else if(d==5){
          k = min(k, rbox(p-vec2(0.0,-0.50), vec2(0.45,0.35), 0.10));
          k = max(k,-rbox(p+vec2(0.0,0.15), vec2(0.45,0.35), 0.10));
          k = min(k, rbox(p+vec2(0.0,-0.65), vec2(0.45,0.35), 0.10));
        } else if(d==6){
          k = rbox(p+vec2(0.10,0.0), vec2(0.35,0.80), 0.10);
          k = max(k,-rbox(p+vec2(0.20,0.0), vec2(0.45,0.50), 0.10));
        } else if(d==7){
          k = min(rbox(p+vec2(0.0,0.65), vec2(0.50,0.15), 0.10),
                  rbox(p+vec2(0.15,0.0), vec2(0.20,0.80), 0.10));
        } else if(d==8){
          k = rbox(p, vec2(0.45,0.80), 0.10);
          k = max(k,-rbox(p, vec2(0.30,0.55), 0.10));
        } else { // 9
          k = rbox(p-vec2(0.10,0.0), vec2(0.35,0.80), 0.10);
          k = max(k,-rbox(p-vec2(0.20,0.0), vec2(0.45,0.50), 0.10));
        }
        return k;
      }

      // tiny triangle mask so the number stays inside the triangle silhouette
      // (approx equilateral clip)
      float triMask(vec2 p){
        // rotate 30deg so plane aligns nicely with icosa face
        float a = radians(30.0);
        mat2 R = mat2(cos(a),-sin(a),sin(a),cos(a));
        p = R*p;
        vec2 q = p; q.y += 0.15;
        float h = sqrt(3.0)/2.0;
        float d = max( abs(q.x)*0.57735 + q.y - h*0.62, max(q.y+h*0.05, 0.0) );
        return step(d, 0.0);
      }

      // little moving “liquid” (simple fbm)
      float hash(vec2 p){ return fract(sin(dot(p,vec2(41.232,27.196)))*43758.5453); }
      float noise(vec2 p){
        vec2 i=floor(p), f=fract(p);
        float a=hash(i), b=hash(i+vec2(1,0));
        float c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
        vec2 u=f*f*(3.0-2.0*f);
        return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
      }
      float fbm(vec2 p){
        float v=0.0, a=0.5; 
        for(int i=0;i<4;i++){ v+=a*noise(p); p*=2.0; a*=0.55; }
        return v;
      }

      void main(){
        // triangle clip
        if(triMask(vUv)==0.0) discard;

        // choose digit: 1..20 (draw 0..9 then 1..10 again)
        int d = int(mod(uNumber-1.0,10.0));
        float sdf = digitSDF(vUv*1.0, d);         // <0 inside numeral stroke
        // expand/contract a bit so different digits read well
        float edge = smoothstep(0.03, -0.03, sdf);

        // “liquid” motion inside engraving
        vec2 uv = vUv*2.0;
        float lq = fbm(uv + vec2(0.15*uTime, -0.10*uTime));
        vec3 liquidCol = mix(vec3(0.85,0.92,1.0), vec3(0.65,0.78,1.0), lq);
        // faint element-like tint shift per face index
        float hueJitter = fract(uNumber*0.123)*0.08;
        liquidCol = mix(liquidCol, liquidCol.bgr, hueJitter);

        // glossy highlight (looks like wet liquid)
        float glow = smoothstep(0.6,1.0, lq) * 0.25;

        vec3 col = liquidCol + glow;

        gl_FragColor = vec4(col, edge*uOpacity);
      }
    `
  });

  const mesh = new THREE.Mesh(geom, mat);
  // slightly shrink so the number sits within the triangle bounds
  mesh.scale.set(0.93, 0.93, 0.93);
  return mesh;
}

/* ----------------------- utils ----------------------- */
function copyV3(src, i, dst, j){
  dst[j  ] = src[i*3  ];
  dst[j+1] = src[i*3+1];
  dst[j+2] = src[i*3+2];
}

// procedural star + nebula equirectangular texture
function makeGalaxyEquirect(w,h){
  const c = document.createElement("canvas");
  c.width = w; c.height = h;
  const ctx = c.getContext("2d");

  // gradient
  const g = ctx.createRadialGradient(w*0.5, h*0.45, h*0.05, w*0.5, h*0.5, h*0.75);
  g.addColorStop(0,   "#0b0b16");
  g.addColorStop(0.5, "#0a0a12");
  g.addColorStop(1,   "#04040a");
  ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

  // faint nebula passes
  for(let i=0;i<3;i++){
    const grad = ctx.createRadialGradient(
      Math.random()*w, Math.random()*h, h*0.02,
      Math.random()*w, Math.random()*h, h*0.45
    );
    const hue = 200 + Math.random()*50;
    grad.addColorStop(0, `hsla(${hue},40%,25%,0.20)`);
    grad.addColorStop(1, "hsla(230,30%,5%,0.0)");
    ctx.fillStyle = grad; ctx.globalCompositeOperation = "lighter";
    ctx.fillRect(0,0,w,h);
    ctx.globalCompositeOperation = "source-over";
  }

  // stars
  ctx.fillStyle = "#ffffff";
  for(let i=0;i<1500;i++){
    const x = Math.random()*w, y = Math.random()*h;
    const r = Math.random()<0.97 ? Math.random()*0.8 : Math.random()*1.8+0.6;
    ctx.globalAlpha = 0.85*Math.random()+0.15;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.mapping = THREE.EquirectangularReflectionMapping;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  return tex;
}

/* ----------------------- resize / animate ----------------------- */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

let t = 0;
function animate(){
  requestAnimationFrame(animate);
  t += 0.016;

  // update “liquid” times
  d20.traverse(o=>{
    if(o.material && o.material.uniforms && o.material.uniforms.uTime){
      o.material.uniforms.uTime.value = t;
    }
  });

  // move sun around D20
  const r = 3.2, spd = 0.25;
  sun.position.set(
    Math.cos(t*spd)*r,
    1.8 + Math.sin(t*spd*0.7)*0.8,
    Math.sin(t*spd)*r
  );

  // very slow star rotation for life
  starSphere.rotation.y = t*0.01;

  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>


