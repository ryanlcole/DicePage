<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shaelvien D20 Shop</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="logo.ico" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
    #phoneFrame {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      width: 360px;
      height: 640px;
      border: 12px solid #333;
      border-radius: 30px;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
      overflow: hidden;
      display: none;
      z-index: 10;
      background: #111;
    }
    #phoneFrame iframe {
      width: 100%;
      height: 100%;
      border: none;
    }
  </style>
</head>
<body>
  <div id="phoneFrame">
    <iframe src="https://linktr.ee/ReLiC_GameMaster"></iframe>
  </div>

  <script type="module">
    import * as THREE from "https://esm.sh/three@0.160.0";
    import { FontLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/FontLoader.js";
    import { TextGeometry } from "https://esm.sh/three@0.160.0/examples/jsm/geometries/TextGeometry.js";

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 6);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // --- Lights ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const key = new THREE.DirectionalLight(0xffffff, 0.8);
    key.position.set(3, 2, 5);
    scene.add(key);

    // --- Background Groups ---
    const bgGroup = new THREE.Group();
    scene.add(bgGroup);

    function makeDiamondShape(size) {
      const shape = new THREE.Shape();
      shape.moveTo(0, size);
      shape.lineTo(size * 0.6, 0);
      shape.lineTo(0, -size);
      shape.lineTo(-size * 0.6, 0);
      shape.lineTo(0, size);
      return shape;
    }

    function makeStarField(count, size, spread, color) {
      const group = new THREE.Group();
      const shape = makeDiamondShape(size);
      const geo = new THREE.ShapeGeometry(shape);
      const mat = new THREE.MeshBasicMaterial({ color, transparent: true });

      for (let i = 0; i < count; i++) {
        const star = new THREE.Mesh(geo, mat.clone());
        star.position.set(
          (Math.random() - 0.5) * spread,
          (Math.random() - 0.5) * spread,
          -Math.random() * 50 - 5
        );
        group.add(star);
      }
      return group;
    }

    const gems = makeStarField(150, 0.05, 40, 0x44ccff);
    const gems2 = makeStarField(120, 0.07, 50, 0xff44cc);
    const vortex = makeStarField(500, 0.015, 60, 0xffffff);

    bgGroup.add(gems);
    bgGroup.add(gems2);
    bgGroup.add(vortex);

    // --- D20 Dice ---
    let d20, texts = [];
    const loader = new FontLoader();

    loader.load("https://threejs.org/examples/fonts/helvetiker_bold.typeface.json", (font) => {
      const radius = 1;
      const geo = new THREE.IcosahedronGeometry(radius, 0);
      const mat = new THREE.MeshStandardMaterial({ color: 0x999999, metalness: 1, roughness: 0.2 });
      d20 = new THREE.Mesh(geo, mat);
      scene.add(d20);

      const pos = geo.attributes.position;
      const index = geo.index;
      const faceCount = index.count / 3;

      for (let i = 0; i < faceCount; i++) {
        const a = index.getX(i * 3);
        const b = index.getX(i * 3 + 1);
        const c = index.getX(i * 3 + 2);

        const vA = new THREE.Vector3().fromBufferAttribute(pos, a);
        const vB = new THREE.Vector3().fromBufferAttribute(pos, b);
        const vC = new THREE.Vector3().fromBufferAttribute(pos, c);
        const center = new THREE.Vector3().addVectors(vA, vB).add(vC).divideScalar(3);

        const textGeo = new TextGeometry((i + 1).toString(), { font, size: 0.25, height: 0.02 });
        const textMat = new THREE.MeshBasicMaterial({ color: new THREE.Color(`hsl(${i * 18},100%,60%)`) });
        const textMesh = new THREE.Mesh(textGeo, textMat);

        textGeo.computeBoundingBox();
        const offset = textGeo.boundingBox.getCenter(new THREE.Vector3()).multiplyScalar(-1);
        textMesh.position.copy(center).add(offset.multiplyScalar(0.01));
        textMesh.lookAt(center.clone().multiplyScalar(2));

        d20.add(textMesh);
        texts.push(textMesh);
      }
    });

    // --- Interactivity ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    window.addEventListener("click", (event) => {
      if (!d20) return;
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(texts);
      if (intersects.length > 0) rollDice(intersects[0].object);
    });

    let rolling = false, rollStart = 0, rollTarget = null;

    function rollDice(selectedFace) {
      rolling = true;
      rollStart = performance.now();
      rollTarget = selectedFace;
    }

    function animate() {
      requestAnimationFrame(animate);
      const elapsed = performance.now();

      // background motion
      bgGroup.rotation.z += 0.0005;
      gems.rotation.x += 0.001;
      gems2.rotation.y -= 0.001;
      vortex.rotation.z += 0.002;

      if (d20 && !rolling) {
        d20.rotation.y += 0.005;
        d20.rotation.x += 0.003;
      }

      if (rolling && d20 && rollTarget) {
        const t = (elapsed - rollStart) / 2500;
        if (t < 1) {
          d20.rotation.x += 0.3;
          d20.rotation.y += 0.4;
          d20.position.z -= 0.05;
          d20.position.y = Math.sin(t * 10) * 0.2;
        } else {
          rolling = false;
          d20.position.set(0, -1.5, -6);
          document.getElementById("phoneFrame").style.display = "block";
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
