<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <title>Shaelvien Dice Mall</title>
  <style>
    :root { color-scheme: dark; }
    html,body{ height:100%; margin:0; }
    body{
      background:#000; overflow:hidden; font-family:system-ui,Segoe UI,Roboto,Ubuntu,sans-serif;
      color:#f8e7c7; /* warm gold like your banner */
    }
    #banner{
      position:fixed; top:2.2rem; left:2.2rem; z-index:10; pointer-events:none;
      font-size: clamp(28px, 4.5vw, 54px); line-height:1.1; text-shadow: 0 0 24px #7b6130;
      letter-spacing:.02em;
    }
    #gl{ position:fixed; inset:0; display:block; background:#000; }
    .fallback{
      position:fixed; inset:0; display:grid; place-items:center; text-align:center; padding:2rem;
    }
    .hidden{ display:none; }
  </style>
</head>
<body>
  <div id="banner">Shaelvien<br>Dice Mall</div>
  <canvas id="gl"></canvas>
  <div id="fallback" class="fallback hidden">
    <div>
      <h2>WebGL not available</h2>
      <p>Try another browser or device. (This page uses a lightweight GPU renderer.)</p>
    </div>
  </div>

  <script>
  (function () {
    const canvas = document.getElementById('gl');
    const showFallback = (msg) => {
      document.getElementById('fallback').classList.remove('hidden');
      if (msg) document.getElementById('fallback').querySelector('p').textContent = msg;
    };

    // --- GL setup -----------------------------------------------------------
    const gl = canvas.getContext('webgl2', { antialias: true, alpha: false, powerPreference: 'high-performance' });
    if (!gl) { showFallback('WebGL2 is required for the immersive renderer.'); return; }

    // DPR-aware sizing
    function resize() {
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      const w = Math.floor(innerWidth * dpr), h = Math.floor(innerHeight * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
        gl.viewport(0, 0, w, h);
      }
    }
    addEventListener('resize', resize, { passive: true }); resize();

    // --- Utilities ----------------------------------------------------------
    const makeShader = (type, source) => {
      const s = gl.createShader(type);
      gl.shaderSource(s, source); gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(s) || 'shader compile error');
      }
      return s;
    };
    const makeProgram = (vs, fs) => {
      const p = gl.createProgram();
      gl.attachShader(p, makeShader(gl.VERTEX_SHADER, vs));
      gl.attachShader(p, makeShader(gl.FRAGMENT_SHADER, fs));
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
      return p;
    };

    // --- Fullscreen starfield (single quad, shader-generated stars) --------
    const starVS = `#version 300 es
    precision highp float;
    const vec2 POS[4] = vec2[4]( vec2(-1.,-1.), vec2(1.,-1.), vec2(-1.,1.), vec2(1.,1.) );
    out vec2 vUv;
    void main(){
      vUv = (POS[gl_VertexID] + 1.0) * 0.5;
      gl_Position = vec4(POS[gl_VertexID], 0., 1.);
    }`;

    const starFS = `#version 300 es
    precision highp float;
    in vec2 vUv;
    out vec4 o;
    uniform vec2 uRes;
    uniform float uTime;

    // Hash & noise for star positions
    float hash(vec2 p){ return fract(sin(dot(p, vec2(41.31, 289.97))) * 143758.5453); }
    float stars(vec2 uv){
      // Tile into cells, place one pseudo-random star per cell
      vec2 g = floor(uv);
      vec2 f = fract(uv) - 0.5;
      float h = hash(g);
      vec2 s = vec2(fract(h * 97.3) - .5, fract(h * 247.1) - .5);
      float d = length(f - s);
      float m = smoothstep(0.02, 0.0, d);
      // twinkle
      float tw = 0.6 + 0.4 * sin(h*1000. + uTime* (1.0 + fract(h*10.)));
      return m * tw;
    }

    void main(){
      vec2 uv = vUv * uRes / min(uRes.x, uRes.y);
      // Parallax drift
      uv += vec2(uTime*0.02, 0.0);
      float layer1 = stars(uv * 60.0);
      float layer2 = stars(uv * 30.0 + 10.0);
      float layer3 = stars(uv * 12.0 + 100.0);
      float s = layer1*0.7 + layer2*0.5 + layer3*0.35;
      // subtle vignette
      vec2 q = (vUv-0.5)*2.0;
      float vig = smoothstep(1.2, 0.1, dot(q,q));
      vec3 col = vec3(s) * (0.9 + 0.1*sin(uTime*0.5));
      col *= vig;
      o = vec4(col, 1.0);
    }`;

    const starProg = makeProgram(starVS, starFS);
    const uStarRes  = gl.getUniformLocation(starProg, 'uRes');
    const uStarTime = gl.getUniformLocation(starProg, 'uTime');

    // --- Procedural Icosahedron (D20) --------------------------------------
    // Generate an icosahedron (12 vertices, 20 faces). Lightweight, no indices expansion needed.
    function makeIcosahedron() {
      const t = (1 + Math.sqrt(5)) / 2;
      const verts = [
        -1,  t,  0,   1,  t,  0,  -1, -t,  0,   1, -t,  0,
         0, -1,  t,   0,  1,  t,   0, -1, -t,   0,  1, -t,
         t,  0, -1,   t,  0,  1,  -t,  0, -1,  -t,  0,  1
      ];
      // Normalize to unit sphere for nice lighting
      for (let i=0;i<verts.length;i+=3){
        const x=verts[i], y=verts[i+1], z=verts[i+2];
        const l = Math.hypot(x,y,z); verts[i]=x/l; verts[i+1]=y/l; verts[i+2]=z/l;
      }
      const f = (a,b,c)=>[a,b,c];
      const faces = [
        f(0,11,5), f(0,5,1), f(0,1,7), f(0,7,10), f(0,10,11),
        f(1,5,9), f(5,11,4), f(11,10,2), f(10,7,6), f(7,1,8),
        f(3,9,4), f(3,4,2), f(3,2,6), f(3,6,8), f(3,8,9),
        f(4,9,5), f(2,4,11), f(6,2,10), f(8,6,7), f(9,8,1)
      ];
      const positions = [];
      for (const tri of faces){
        for (const idx of tri){
          positions.push(verts[idx*3], verts[idx*3+1], verts[idx*3+2]);
        }
      }
      return new Float32Array(positions);
    }

    const d20Positions = makeIcosahedron();

    const d20VS = `#version 300 es
    precision highp float;
    layout(location=0) in vec3 position;
    uniform mat4 uProj, uView, uModel;
    out vec3 vN;
    out vec3 vWPos;
    void main(){
      vec4 wp = uModel * vec4(position, 1.0);
      vWPos = wp.xyz;
      // normal from model (icosahedron faces are flat; we'll face-normal in fragment)
      vN = mat3(uModel) * normalize(position);
      gl_Position = uProj * uView * wp;
    }`;

    const d20FS = `#version 300 es
    precision highp float;
    in vec3 vN;
    in vec3 vWPos;
    out vec4 o;
    uniform vec3 uCam;
    uniform float uTime;

    vec3 ldir = normalize(vec3(0.8, 1.0, 0.6));

    void main(){
      // simple toonish lighting + a cool hue shift
      vec3 n = normalize(vN);
      float diff = max(dot(n, ldir), 0.0);
      float spec = pow(max(dot(reflect(-ldir, n), normalize(uCam - vWPos)), 0.0), 32.0);

      // base color shifts slowly over time (subtle)
      float h = 0.6 + 0.4 * sin(uTime * 0.25 + vWPos.y*2.0);
      vec3 base = mix(vec3(0.55,0.52,0.60), vec3(0.35,0.45,0.9), h);

      vec3 col = base * (0.2 + 0.8*diff) + spec*0.25;
      // crisp edge highlight
      float rim = pow(1.0 - max(dot(n, normalize(uCam - vWPos)), 0.0), 3.0);
      col += rim * 0.25;

      o = vec4(col, 1.0);
    }`;

    const d20Prog = makeProgram(d20VS, d20FS);
    const d20Buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, d20Buf);
    gl.bufferData(gl.ARRAY_BUFFER, d20Positions, gl.STATIC_DRAW);

    const aPosLoc = 0;
    gl.enableVertexAttribArray(aPosLoc);
    gl.vertexAttribPointer(aPosLoc, 3, gl.FLOAT, false, 0, 0);

    // Uniforms
    const uProj  = gl.getUniformLocation(d20Prog,'uProj');
    const uView  = gl.getUniformLocation(d20Prog,'uView');
    const uModel = gl.getUniformLocation(d20Prog,'uModel');
    const uCam   = gl.getUniformLocation(d20Prog,'uCam');
    const uD20Time = gl.getUniformLocation(d20Prog,'uTime');

    // --- Minimal math (mat4) -----------------------------------------------
    function mat4Identity(){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
    function mat4Multiply(a,b){
      const o = new Array(16);
      for (let i=0;i<4;i++){
        for (let j=0;j<4;j++){
          o[i*4+j] = a[i*4+0]*b[0*4+j] + a[i*4+1]*b[1*4+j] + a[i*4+2]*b[2*4+j] + a[i*4+3]*b[3*4+j];
        }
      }
      return o;
    }
    function mat4RotateY(m,a){
      const c=Math.cos(a), s=Math.sin(a);
      const r=[c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1];
      return mat4Multiply(m,r);
    }
    function mat4RotateX(m,a){
      const c=Math.cos(a), s=Math.sin(a);
      const r=[1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1];
      return mat4Multiply(m,r);
    }
    function mat4Translate(m, v){
      const r = m.slice();
      r[12]+=v[0]; r[13]+=v[1]; r[14]+=v[2];
      return r;
    }
    function mat4Perspective(fovy, aspect, near, far){
      const f = 1/Math.tan(fovy/2), nf = 1/(near-far);
      return [f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0];
    }
    function lookAt(eye,center,up){
      const zx = eye[0]-center[0], zy=eye[1]-center[1], zz=eye[2]-center[2];
      const zl = Math.hypot(zx,zy,zz); const z0=zx/zl, z1=zy/zl, z2=zz/zl;
      const xx = up[1]*z2 - up[2]*z1, xy = up[2]*z0 - up[0]*z2, xz = up[0]*z1 - up[1]*z0;
      const xl = Math.hypot(xx,xy,xz); const x0=xx/xl, x1=xy/xl, x2=xz/xl;
      const y0 = z1*x2 - z2*x1, y1 = z2*x0 - z0*x2, y2 = z0*x1 - z1*x0;
      return [
        x0, y0, z0, 0,
        x1, y1, z1, 0,
        x2, y2, z2, 0,
        -(x0*eye[0]+x1*eye[1]+x2*eye[2]),
        -(y0*eye[0]+y1*eye[1]+y2*eye[2]),
        -(z0*eye[0]+z1*eye[1]+z2*eye[2]),
        1
      ];
    }

    // --- Interaction (drag inertia) ----------------------------------------
    let rotX = 0.25, rotY = 0.5;
    let vx = 0, vy = 0, lastX=0, lastY=0, dragging=false, lastMove=performance.now();

    const start = (e)=>{ dragging=true; const t=(e.touches?e.touches[0]:e); lastX=t.clientX; lastY=t.clientY; };
    const move = (e)=>{
      if(!dragging) return;
      const t=(e.touches?e.touches[0]:e);
      const dx = (t.clientX-lastX)/innerWidth;
      const dy = (t.clientY-lastY)/innerHeight;
      lastX=t.clientX; lastY=t.clientY;
      rotY += dx*3.5;
      rotX += dy*3.5;
      vx = dx*6.0; vy = dy*6.0;
      lastMove = performance.now();
    };
    const end = ()=>{ dragging=false; };
    canvas.addEventListener('pointerdown', start, {passive:true});
    canvas.addEventListener('pointermove', move, {passive:true});
    canvas.addEventListener('pointerup', end, {passive:true});
    canvas.addEventListener('pointerleave', end, {passive:true});
    canvas.addEventListener('touchstart', start, {passive:true});
    canvas.addEventListener('touchmove', move, {passive:true});
    canvas.addEventListener('touchend', end, {passive:true});

    // --- Render loop --------------------------------------------------------
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0,0,0,1);

    function render(t) {
      resize();
      const time = t*0.001;

      // Auto-spin after 2s idle
      if (!dragging && performance.now() - lastMove > 2000) {
        rotY += 0.25 * 0.016;
      } else {
        // gentle inertia
        rotY += vx * 0.016; rotX += vy * 0.016;
        vx *= 0.94; vy *= 0.94;
      }
      rotX = Math.max(-1.5, Math.min(1.5, rotX));

      // 1) Starfield
      gl.disable(gl.DEPTH_TEST);
      gl.useProgram(starProg);
      gl.uniform2f(uStarRes, canvas.width, canvas.height);
      gl.uniform1f(uStarTime, time);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      // 2) D20
      gl.enable(gl.DEPTH_TEST);
      gl.useProgram(d20Prog);

      const aspect = canvas.width / canvas.height;
      const proj = mat4Perspective(45*Math.PI/180, aspect, 0.1, 50);
      const eye = [0, 0, 3.2];
      const view = lookAt(eye, [0,0,0], [0,1,0]);

      let model = mat4Identity();
      model = mat4RotateX(model, rotX);
      model = mat4RotateY(model, rotY);
      model = mat4Translate(model, [0,0,0]);

      gl.uniformMatrix4fv(uProj,false,new Float32Array(proj));
      gl.uniformMatrix4fv(uView,false,new Float32Array(view));
      gl.uniformMatrix4fv(uModel,false,new Float32Array(model));
      gl.uniform3f(uCam, eye[0], eye[1], eye[2]);
      gl.uniform1f(uD20Time, time);

      gl.drawArrays(gl.TRIANGLES, 0, d20Positions.length/3);

      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  })();
  </script>
</body>
</html>

