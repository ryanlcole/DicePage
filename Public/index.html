<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Shaelvien Engraved D20</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/FontLoader.js';
  import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/geometries/TextGeometry.js';
  import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/RGBELoader.js';

  // === Scene ===
  const scene = new THREE.Scene();

  // === Camera ===
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 8);

  // === Renderer ===
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  document.body.appendChild(renderer.domElement);

  // === Controls ===
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // === Environment (HDRI for reflections) ===
  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();

  new RGBELoader()
    .setPath('https://threejs.org/examples/textures/equirectangular/')
    .load('royal_esplanade_1k.hdr', (hdrEquirect) => {
      const envMap = pmremGenerator.fromEquirectangular(hdrEquirect).texture;
      scene.background = envMap;      // makes background reflective
      scene.environment = envMap;     // applies reflections to metals
      hdrEquirect.dispose();
      pmremGenerator.dispose();

      createDice(); // only build dice after env is ready
    });

  // === Create Dice ===
  function createDice() {
    const radius = 2;
    const geometry = new THREE.IcosahedronGeometry(radius, 0);

    // Titanium material
    const titaniumMat = new THREE.MeshStandardMaterial({
      color: 0xb0b0b0,
      metalness: 1.0,
      roughness: 0.2,
      envMapIntensity: 1.5
    });

    const d20 = new THREE.Mesh(geometry, titaniumMat);
    scene.add(d20);

    // Mercury numbers
    const mercuryMat = new THREE.MeshStandardMaterial({
      color: 0xd8d8ff,
      metalness: 1.0,
      roughness: 0.05,
      emissive: 0x222222,
      envMapIntensity: 2.0
    });

    const loader = new FontLoader();
    loader.load(
      'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',
      (font) => {
        const pos = geometry.attributes.position;
        const index = geometry.index;
        const faceCenters = [];

        for (let i = 0; i < index.count; i += 3) {
          const a = index.getX(i), b = index.getX(i+1), c = index.getX(i+2);
          const vA = new THREE.Vector3().fromBufferAttribute(pos, a);
          const vB = new THREE.Vector3().fromBufferAttribute(pos, b);
          const vC = new THREE.Vector3().fromBufferAttribute(pos, c);
          const center = new THREE.Vector3().addVectors(vA, vB).add(vC).divideScalar(3);
          faceCenters.push(center);
        }

        faceCenters.forEach((center, i) => {
          const textGeo = new TextGeometry((i+1).toString(), {
            font,
            size: 0.4,
            height: 0.05,
            bevelEnabled: true,
            bevelThickness: 0.01,
            bevelSize: 0.01,
            bevelSegments: 2
          });
          const textMesh = new THREE.Mesh(textGeo, mercuryMat);

          const normal = center.clone().normalize();
          textMesh.position.copy(center).addScaledVector(normal, 0.1);

          const quat = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, 1), normal
          );
          textMesh.quaternion.copy(quat);

          d20.add(textMesh);
        });
      }
    );

    // Animate
    function animate() {
      requestAnimationFrame(animate);
      d20.rotation.x += 0.003;
      d20.rotation.y += 0.004;
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  }

  // Resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>




